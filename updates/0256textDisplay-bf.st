'For text with no background use project background and white type'Textframe understands: 'clearfrom: y 	[((frame origin x  y rect: frame corner) intersect: window) clear: [bg  nil  [background] bg]]' classified: 'as yet unclassified'Textframe understands: 'displaylines: first to: last | rect a d h scanner y i line	[first _ first max: (self lineofy: window minY).	last _ last min: (self lineofy: window maxY).	rect _ window minX(self yofline: first) rect: window maxX((self yofline: last) + style lineheight).	if style linelead < 0 then		"render additional lines if they overlap"		[self maxAscent a andDescent d.		h _ a - style baseline max: style baseline + d - style lineheight.		first _ first - (h / style lineheight + 2) max: 1.		last _ last + (h / style lineheight + 2) min: lastline.		rect origin y _ rect origin y - h.		rect corner y _ rect corner y + h - style lineheight].	(rect intersect: window) clear: [bg  nil  [background] bg].	scanner _ self printer: true.	y _ self yofline: first.	for i from: first to: last do		[line _ lines  i.		scanner scanline: line at: y stopx: window maxX stopchar: line stopi.		y _ y + style lineheight].	y]' classified: 'as yet unclassified'Textframe understands: 'frame: f window: w para: p style: s 	[frame _ f.	window _ w.	para _ p.	style _ s.	[NoteTaker or frame  nil  []	window _ frame intersect: user screenrect.	frame _ window].	lines _ Vector new: 32.	lastline _ 0.	bg _ white.	para  nil or frame  nil  []	self measureall]' classified: 'as yet unclassified'Textframe understands: 'printer: printing | p	[p _ TextScanner new frame: frame window: window para: para style: style printing: printing.	[(bg  nil or bg = black) and p function = oring  [p function _ 7]].	p]' classified: 'as yet unclassified'TextScanner understands: 'frame: f window: w para: p style: s printing: b	[frame _ f.	para _ p.	style _ s.	printing _ b.	super init.	self toDisplay.	function _ [style effect = 0  [oring] style effect].	exceptions _ defaultExceptions.	fontno _ 1.	para _ para asParagraph.	text _ para text.	NoteTaker  [self window: w]]' classified: 'as yet unclassified'TextScanner understands: 'scanline: line at: lineY stopx: sx stopchar: stopChar | nullChar xOfLastSpace stopCode emphasis runAndVal endOfRun padding relX tabsize spacePad alignment	[stopx _ sx.	chari _ line starti - 1.	spacecount _ line spaces.	padding _ line padwidth.	destx _ spacex _ xOfLastSpace _ frame minX.	spacePad _ charpad _ emphasis _ 0.	tabsize _ style tabsize.	spacei _ 1.	alignment _ para alignment.	[alignment = 0 "left"  []	alignment = 1 "justify" 		[spacecount > 0 			[charpad _ padding / (line stopi - chari + spacecount).			[charpad > 0 				[padding _ padding - (charpad * (line stopi - chari - 2 - spacecount))]].			spacePad _ padding / spacecount.			spacecount _ spacecount - (padding \ spacecount)]]	alignment = 2 "center"  [destx _ destx + (padding / 2)]	alignment = 4 "right"  [destx _ destx + padding]].	stopCode _ 10.	until stopCode < 10 do		[stopCode = 10 			[stopCode _ 255.			chari  stopChar  [stopCode _ 3]			if printing then [self emphasize: emphasis leftx: xOfLastSpace rightx: destx liney: lineY].			xOfLastSpace _ destx.			chari _ chari + 1.			runAndVal _ para runAndVal: chari.			emphasis _ runAndVal2 land: 15.			endOfRun _ runAndVal1 + chari - 1 min: stopChar.			self setfont: (runAndVal2 lshift: 4) liney: lineY]		stopCode _ self scanword: endOfRun.		stopCode > 10 			[	[stopCode = 12  "space"					[spacecount _ spacecount - 1.					[spacecount = 0  [spacePad _ spacePad + 1]].					spacei _ chari.					spacex _ destx.					width _ spacesize + spacePad]				stopCode = 13  "tab"					[relX _ destx - frame minX.					width _ [para alignment > 0  [tabsize + charpad]							relX + tabsize | tabsize - relX]]				stopCode = 11  "no glyph"					[nullChar _ maxascii + 1.					sourcex _ xtable(nullChar + 1).					width _ xtable(nullChar + 2) - sourcex.					if printing then [self callBLT].					width _ width + charpad]].			destx _ destx + width.			destx > stopx  [stopCode _ 2]			chari  endOfRun  [stopCode _ 10]			chari _ chari + 1]		stopCode = 4  [width _ 0]].	printing  [self emphasize: emphasis leftx: xOfLastSpace rightx: destx liney: lineY]]' classified: 'as yet unclassified'TextScanner derstands: 'type:' unique.