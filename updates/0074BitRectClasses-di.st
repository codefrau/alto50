'The four BitRect classes for Ted''s editor'Class new title: BitRect	subclassof: Rectangle	fields: 'height width stripheight data'	declare: 'defaultpic ';	classified: 'Panes and Menus'Class new title: BitRectEditor	subclassof: Window	fields: 'tool saveToolPic saveActionPic picture dirty'	declare: 'tools toolpic actionpic actionbuttons windowmenu ';	classified: 'Windows'Class new title: BitRectTool	subclassof: Object	fields: 'action mode penwidth gray grid brush brushpt  pencil tone'	declare: 'blowupScale graypens ';	classified: 'As yet unclassified'Class new title: RadioButtons	subclassof: Object	fields: 'rect cur vec'	declare: '';	classified: 'Panes and Menus'BitRect understands: '= x [selfx]' classified: 'As yet unclassified'BitRect understands: 'bitsOntoStream: strm | bits	[for bits from: data do [strm append: bits]]' classified: 'As yet unclassified'BitRect understands: 'classComment [ ''BitRect is a Rectangle that remembers the bits within it.To create and edit one, say:		BitRect new fromuser edit.This installs a BitRectEditor in the scheduler and starts it up.The editor is explained in BitRectEditor.'']' classified: 'As yet unclassified'BitRect understands: 'classInit	["the default picture is a gray rectangle"	"defaultpic _ BitRect new filin: ''defaultpic'' - wont work now"]' classified: 'As yet unclassified'BitRect understands: 'copyBitsFrom: other		| clippedStrip i j myStrips otherStrips myStrip otherStrip	["copy all bits from other that are within my area"	myStrips_self strips.  otherStrips_other strips.	for i to: myStrips length do		[for j to: otherStrips length do			[myStrip_myStripsi.  otherStrip_otherStripsj.			clippedStrip_myStrip intersect: otherStrip.			clippedStrip empty[]			BitBlt init function_0;				destbase_datai;				destraster_myStrip width+15/16;				dest_clippedStrip origin-myStrip origin;				extent_clippedStrip extent;				sourcebase_other dataj;				sourceraster_otherStrip width+15/16;				source_clippedStrip origin-otherStrip origin;				checksandcall]]]' classified: 'As yet unclassified'BitRect understands: 'corner_x [self growby: x-corner]' classified: 'As yet unclassified'BitRect understands: 'data [data]' classified: 'As yet unclassified'BitRect understands: 'default [defaultpic recopy]' classified: 'As yet unclassified'BitRect understands: 'edit | a	[user leaveTop.	a_BitRectEditor new picture: self.	a takeCursor; enter.	user restartup: a]' classified: 'As yet unclassified'BitRect understands: 'extent_x [self growby: x-self extent]' classified: 'As yet unclassified'BitRect understands: 'filin: title | f i x y rect strips  "read bits from a file"	[f_dp0 oldFile: (title concat: ''.pic.'').	f readonly.	f end[f close. user notify: ''no data'']	x_f nextword.  y_f nextword.	rect_Rectangle new origin: [origin is: Point[origin] 00] extent: xy.	self title: title in: rect.	stripheightf nextword[user notify: ''strip heights dont match'']	strips _ self strips.	for i to: strips length do		[f into: datai].	f close]' classified: 'As yet unclassified'BitRect understands: 'filout | f i  "write bits on a file"	[f _ dp0 file: (title concat: ''.pic.'').	f nextword _ self extent x.	f nextword _ self extent y.	f nextword _ stripheight.	for i from: data do [f append: i].	f close]' classified: 'As yet unclassified'BitRect understands: 'fromuser	[self title: ''BitRect'' in: Rectangle new fromuser.	self saveScreenBits]' classified: 'As yet unclassified'BitRect understands: 'growby: change | old	[old_BitRect new origin: origin corner: corner title: title		stripheight: stripheight data: data.	self title: title in: (origin rect: corner+change).	self copyBitsFrom: old]' classified: 'As yet unclassified'BitRect understands: 'growto: x [self growby: x-corner]' classified: 'As yet unclassified'BitRect understands: 'hash [user croak] primitive: 46' classified: 'As yet unclassified'BitRect understands: 'height_h [self growby: 0(h-self extent y)]' classified: 'As yet unclassified'BitRect understands: 'length [self bitStringLength]' classified: 'As yet unclassified'BitRect understands: 'origin: origin corner: corner title: title stripheight: stripheight data: data' classified: 'As yet unclassified'BitRect understands: 'presson: press in: r | w h hs scale w16 y [	scale _ press scale.	h _ self height.	(hs  _ scale*h) > r height [		"not enough room left on current page.		assume for now that it will at least fit on an entire page"		self]	w _ self width.	w16 _ w + 15 | 16 "width to next word boundary".	"with w, prints on viola but not on spruce.	with w16, prints on spruce with garbage on end"	press setp: 0(y _ r corner y - hs);		dots [			press setcoding: 1 "bitmap" dots: w16 lines: h;				setmode: 3 "to right and to bottom";				setsizewidth: scale*w16 height: hs;				setwindowwidth: w16 height: h;				dotsfollow.			self bitsOntoStream: press data].	y]' classified: 'As yet unclassified'BitRect understands: 'printon: strm	[strm append: ''a BitRect'']' classified: 'As yet unclassified'BitRect understands: 'saveScreenBits | strips i	[strips_self strips.	for i to: strips length do		[stripsi bitsIntoString: datai mode: storing clippedBy: nil]]' classified: 'As yet unclassified'BitRect understands: 'show | strips i	[strips_self strips.	for i to: strips length do		[stripsi bitsFromString: datai]]' classified: 'As yet unclassified'BitRect understands: 'strips   "return a vector of strips (Rectangles)"		| nStrips strips stripOrigin stripExtent i	[(nStrips_data length)=1[self inVector]	strips_Vector new: nStrips.	stripOrigin_origin.  stripExtent_self widthstripheight.	for i to: nStrips-1 do		[stripsi_Rectangle new origin: stripOrigin extent: stripExtent.		stripOrigin_stripOrigin+(0stripheight)].	stripsnStrips_Rectangle new origin: stripOrigin corner: corner.	strips]' classified: 'As yet unclassified'BitRect understands: 'title [title]' classified: 'As yet unclassified'BitRect understands: 'title: title in: rect | nStrips i strips	[origin_rect origin.  corner_rect corner.	"the strip height is chosen so that each bitstring is about 2048 bytes"	stripheight_1023/((self extent x + 15)/16).	nStrips_(self extent y+stripheight-1)/stripheight.	data_Vector new: nStrips.	strips_self strips.	for i to: nStrips do		[datai_String new: (stripsi) bitStringLength]]' classified: 'As yet unclassified'BitRect understands: 'width_w [self growby: (w-self extent x)0]' classified: 'As yet unclassified'BitRectEditor understands: 'actionpic: a [actionpic _ a]' classified: 'As yet unclassified'BitRectEditor understands: 'bluebug | 	[	picture is: BitImage [  picture fromrectangle: (picture rectangle)]	windowmenu bug	 =1 [self leave. exitflag _ false];  "under"	=2 [self leave; newframe; enter];  "move"	=3 [self grow  "grow"];	=4 [self leave; erase.   "close"		 user unschedule: self. false];	=5 [self leave. picture filout. self enter];  "filout"	=6 [self print]	"press file"]' classified: 'As yet unclassified'BitRectEditor understands: 'classComment [''BitRectEditor edits BitRects.To create, say:	BitRect new fromuser edit.This installs a BitRectEditor in the scheduler and starts it up.The editing tools are to the left of the picture.  (The first one looks like a doodle).  They are: draw-thin, erase, straightedge, gray-block, paintbrush, magnifier.  The actions for the tools are displayed above the picture.See BitRectTool for explanations of the actions.CAUTION: this ordering is arbitrary.  It is currently possible to set a new action for any of the tools, so that if you are not careful, the straightedge will start being a magnifier or whatever.  This should get fixed eventually.tools = a RadioButtons. Each button owns a BitRectTool (the active one is held in tool).actionbuttons = a Vector of RadioButtons.  The groups of buttons are: action, mode, pen width, gray, and grid.toolpic = BitRect of icons for the tools (at side of picture).actionpic = BitRect of icons for the parts of a tool (above picture)windowmenu = menu for bluebug.To edit a copy of the tool picture, say	newpic_(BitRectEditortoolpic) recopy.	newpic edit.To install this copy as the menu picture, say	BitRectEditor new toolpic: newpic recopy.Do the analogous thing to edit the action picture.Caution: the editor blows up if you edit the tool picture itself and not a copy.'']' classified: 'As yet unclassified'BitRectEditor understands: 'classInit | t i	[t _ Vector new: 6.	for i to: t length do [ti _ BitRectTool new init].	tools _ (RadioButtons new) vec: t at: 00 width: 20.	windowmenu _ Menu new string: ''undermovegrowclosefiloutprintbits''.	actionpic_BitRect new filin: ''actionpic''.	toolpic_BitRect new filin: ''toolpic''.	self initmenu1]' classified: 'As yet unclassified'BitRectEditor understands: 'enter | start pt b	["Periodically check if the mouse is still in the frame.		If not, stop showing the picture"	super show.  self lostMouse[false]	picture show.  dirty_false.  self lostMouse[false]	for b from: actionbuttons do [b reset].	"show action menu above the picture"	start_frame origin-1.	pt _ start-(0actionpic extent y).	actionpic moveto: pt.	saveActionPic_actionpic bitsIntoString.	self lostMouse[false]	"last point I can return before having to restore bits under menus"	actionpic show.	pt _ actionbuttons1 moveto: pt. "action"	pt _ actionbuttons3 moveto: pt. "mode"	pt _ actionbuttons4 moveto: pt. "width"	"show the next bank of action buttons"	pt _ start-(0(actionpic extent y+1/2)).	pt _ actionbuttons2 moveto: pt.  "tone"	pt _ actionbuttons5 moveto: pt.  "grid"	tool brushpt: (pt _ pt+(77)).	(tool brush) moveto: pt; show.	"show the tool pic"	pt _ start-(toolpic extent x0).	toolpic moveto: pt.	saveToolPic _ toolpic bitsIntoString.	toolpic show.	tools moveto: pt;  setvalue: tool.	tool frame: frame; showon: actionbuttons.]' classified: 'As yet unclassified'BitRectEditor understands: 'fixframe: r	[picture moveto: r origin.	r corner_picture corner.	r]' classified: 'As yet unclassified'BitRectEditor understands: 'grow | oldframe newframe pt r	[self leave.	newframe_picture origin rect: picture corner.	CornerCursor showwhile		[pt_user mp+16.		while user nobug do			[newframe corner_pt.  newframe comp.			pt_user mp+16.  newframe comp].		while user anybug do			[newframe corner_pt.  newframe comp.			pt_user mp+16.  newframe comp]].	"clear unused areas from old picture to background,		and clear new picture areas to white"	oldframe_picture inset: 22.  "2 is for erasing old border"	for r from: (oldframe minus: newframe) do [r clear: background].	for r from: (newframe minus: picture) do [r clear: white].	picture title: picture title in: newframe; saveScreenBits.	self frame: newframe; show; takeCursor; enter]' classified: 'As yet unclassified'BitRectEditor understands: 'initmenu1 | s z	[s _ Vector new: 5. z _ 20.	s1 _ (RadioButtons new) vec: (setbrush paint block draw line blowup) at: 00 height: z. "action"	s2 _ (RadioButtons new) vec: (black, dkgray, gray, ltgray, white) at: 00 height: z. "tone"	s3 _ (RadioButtons new) vec: (0, 1, 2, 3) at: 00 height: z. "mode"	s4 _ (RadioButtons new) vec: (1, 2, 4, 8) at: 00 height: z. "width"	s5 _ (RadioButtons new) vec: (1, 2, 4, 8, 16, 32) at: 00 height: z. "grid"	actionbuttons _ s.]' classified: 'As yet unclassified'BitRectEditor understands: 'leave	[[nilsaveActionPic[]	 actionpic bitsFromString: saveActionPic.	 saveActionPic _ nil.].	 [nil saveToolPic[]	 toolpic bitsFromString: saveToolPic.	 saveToolPic_nil].	[dirty[picture saveScreenBits. dirty _ false]].	frame border: 3 color: white]' classified: 'As yet unclassified'BitRectEditor understands: 'lostMouse [(frame has: user mp)false]' classified: 'As yet unclassified'BitRectEditor understands: 'outside | pt	[toolpic has: (pt_user mp)		[user redbug			[tool_tools bug: pt. tool frame: frame; showon: actionbuttons]]	actionpic has: pt		[user redbug			[tool setfrom: actionbuttons]]	false]' classified: 'As yet unclassified'BitRectEditor understands: 'picture: picture	[tool _ tools push: 1.	self frame: (picture origin rect: picture corner)]' classified: 'As yet unclassified'BitRectEditor understands: 'redbug [dirty_true.  tool redbug]' classified: 'As yet unclassified'BitRectEditor understands: 'showtitle   "The BitRectEditor have a menu where the title used to be"' classified: 'As yet unclassified'BitRectEditor understands: 'title [picture title]' classified: 'As yet unclassified'BitRectEditor understands: 'tool [ tool]' classified: 'As yet unclassified'BitRectEditor understands: 'toolpic: a [toolpic _ a]' classified: 'As yet unclassified'BitRectEditor understands: 'yellowbug	[picture is: BitImage [ picture yellowbug] 	]' classified: 'As yet unclassified'BitRectTool understands: 'block [self getRectangle color: tone mode: mode]' classified: 'As yet unclassified'BitRectTool understands: 'blowup | smallRect bigRectFrame	[smallRect_self getRectangle.	bigRectFrame _ Rectangle new origin: smallRect corner		extent: 44 + (smallRect  extent*blowupScale).	smallRect empty or bigRectFrame bitStringLength>4000		[pencil frame flash.  nil].	[user screenrect has: bigRectFrame corner[] 		bigRectFrame moveto: smallRect origin-bigRectFrame extent.		user screenrect has: bigRectFrame origin[]		"can''t find a space for blown up image"			pencil frame flash.  nil].	self blowup: smallRect to: bigRectFrame]' classified: 'As yet unclassified'BitRectTool understands: 'blowup: smallRect to: bigRectFrame		| bigRect box pt i turt flag bits	[bits _ bigRectFrame bitsIntoString.	bigRect _ bigRectFrame inset: 22.	smallRect blowup: bigRect origin by: blowupScale.	turt_Turtle init.	box _ 00 rect: (blowupScale-1)(blowupScale-1).	"keep editing in blowup mode until the user presses a button		outside the big rect"	while flag do		[bigRect has: (pt _ user mp)			[box moveto: bigRect origin + (i _ pt-bigRect origin|blowupScale).			turt place: smallRect origin + (i/blowupScale).			user redbug[box color: black mode: storing. 				turt black; go: 0]			user yellowbug[box color: white mode: storing. 				turt white; go: 0]			user bluebug[bigRect flash]]				user anybug 			[(bigRect inset: 55) has: pt[bigRect flash]			"quit" flag_false]].	bigRectFrame bitsFromString: bits]' classified: 'As yet unclassified'BitRectTool understands: 'brush [brush]' classified: 'As yet unclassified'BitRectTool understands: 'brush: sourceRect   "use the bits in the BitRect sourceRect as a brush"		| minpt maxpt pt offset	["The inner painting loop should be fast - all the extra foliage below		is to move tests outside of the inner loop"	sourceRect moveto: brushpt; show.	minpt_self frame origin.	maxpt_self frame corner-sourceRect extent.	offset_sourceRect extent/2.	"If mode is storing or oring, use brush command, otherwise blt.		Use the unclipped form of brushing  and grid=1 when possible"	[mode<xoring and grid=1		[while user redbug do			[minpt(pt_user mp-offset) and ptmaxpt				[sourceRect brush: pt mode: mode color: tone]			sourceRect brush: pt mode: mode color: tone clippedBy: self frame]]	 modexoring and grid=1		[while user redbug do			[minpt(pt_user mp-offset) and ptmaxpt				[sourceRect blt: pt mode: mode]			sourceRect blt: pt mode: mode clippedBy: self frame]]	 mode<xoring   "grid is > 1"		[while user redbug do			[minpt(pt_self mpOnGrid-offset) and ptmaxpt				[sourceRect brush: pt mode: mode color: tone]			sourceRect brush: pt mode: mode color: tone clippedBy: self frame]]	 "grid is > 1 and modexoring"		while user redbug do			[minpt(pt_self mpOnGrid-offset) and ptmaxpt				[sourceRect blt: pt mode: mode]			sourceRect blt: pt mode: mode clippedBy: self frame]].	]' classified: 'As yet unclassified'BitRectTool understands: 'brushpt: pt  "set the point at which the current brush will be shown"	[brushpt_pt]' classified: 'As yet unclassified'BitRectTool understands: 'classComment [ ''A BitRectTool paints on the screen.A tool is a combination of action, mode, pen-width, gray, and grid.	action is one of: make-brush, paint, block-of-gray, draw, straight-edge, magnify.	mode is one of: store, or, xor, and.  (how tool is combined with picture)	pen-width is 1, 2, 4, or 8.  (width of the pen)	gray is one of: black, darkgray, gray, lightgray, white.	grid is one of: 1, 2, 4, 8, 16, 32.   (minimum spacing of mouse points)Menus for each part of a tool appear above the picture (in the same order).Some actions do not use certain of the other parts of a tool.(example: Block-of-gray does not use pen-width.)brushpt = Point in the menu where brush is shown.graypens = Vector of Strings of bits in pens.'']' classified: 'As yet unclassified'BitRectTool understands: 'classInit | rect saveBits t i	[blowupScale_4.	"make a vector of gray pens"	rect _ 00 rect: 99.	saveBits_rect bitsIntoString.	t _ Turtle init.	graypens _ Vector new: 8.	for i to: 8 do		[t width: i.		rect clear: white. 		t place: 44; go: 0. 		graypensi _ BitRect new title: ''graypen'' in: rect.		(graypensi) saveScreenBits].	rect bitsFromString: saveBits]' classified: 'As yet unclassified'BitRectTool understands: 'draw	[tone=white or tone=black		[pencil place: self mpOnGrid-pencil frame origin.		grid=1		"make drawing with grid 1 fast"			[while user redbug do				[pencil goto: user mp-pencil frame origin]]		while user redbug do			[pencil goto: self mpOnGrid-pencil frame origin]]	self brush: graypenspencil width]' classified: 'As yet unclassified'BitRectTool understands: 'frame [pencil frame]' classified: 'As yet unclassified'BitRectTool understands: 'frame: f [pencil frame: f]' classified: 'As yet unclassified'BitRectTool understands: 'getRectangle | rect newrect start t   "rect must be in my frame"	["the rect-newrect stuff is so that the complementing stays		on for a while"	start_self mpOnGrid.	rect_newrect_(Rectangle new origin: start corner: start)		intersect: self frame.	"move the cursor slightly so that the user will notice the rectangle		being complemented"	user cursorloc_start+4.	while user anybug do		[rect_newrect.		rect comp.		t_self mpOnGrid.		newrect_(Rectangle new origin: (start min: t) corner: (start max: t))			intersect: self frame.		rect comp].	rect]' classified: 'As yet unclassified'BitRectTool understands: 'init	[(pencil _ Turtle new) init; black; width: 2.	(brush _ BitRect new) title: ''brush'' in: (00 rect: 1616).	tone _ black. mode _ 0. grid _ 1. action _ draw]' classified: 'As yet unclassified'BitRectTool understands: 'line | start end width	[start_end_self mpOnGrid-pencil frame origin.	width_pencil width.  pencil xor; width: 1.	while user redbug do		[end_self mpOnGrid-pencil frame origin.		pencil xor; place: start; goto: end; place: start; goto: end].	[tone=white[pencil white] pencil black].	pencil width: width; place: start; goto: end]' classified: 'As yet unclassified'BitRectTool understands: 'mode	[ mode]' classified: 'As yet unclassified'BitRectTool understands: 'mpOnGrid   "return mouse point rounded to grid"	[user mp+(grid/2) | grid]' classified: 'As yet unclassified'BitRectTool understands: 'paint	[self brush: brush]' classified: 'As yet unclassified'BitRectTool understands: 'redbug [self perform: action]' classified: 'As yet unclassified'BitRectTool understands: 'setbrush | rect	[rect_self getRectangle.	rect empty or 5050<rect extent[pencil frame flash].	brush color: white mode: storing.	brush title: ''brush'' in: rect; saveScreenBits.	brush moveto: brushpt; show.	action _ paint]' classified: 'As yet unclassified'BitRectTool understands: 'setfrom: butvec | pt	[butvec1 has: (pt _ user mp) 		[action _ butvec1 bug: pt]	butvec2 has: pt [tone _ butvec2 bug: pt.		tone=white [pencil white] pencil black]	butvec3 has: pt [mode _ butvec3 bug: pt]	butvec4 has: pt [pencil width: (butvec4 bug: pt)]	butvec5 has: pt [grid _ butvec5 bug: pt]	]' classified: 'As yet unclassified'BitRectTool understands: 'shade | p1 p2 a b t p r vs "down on redbug is black place.	up on redbug is white place.  Subsequent redbugs	paint a shade of gray depending on position between	black and white (and beyond white to black again).	Yellow or blue bug terminates."	[until user redbug do [p1 _ user mp]. "black"	until user nobug do [p2 _ user mp]. "white"	vs _ ( 1  1025  1089  585  4681  6731  22058  27031   26986  31191  32108   5160  5128  8321  1025 01 0).	r _ 00 rect: 1010.	b_(p1-p2). b _ b x asFloat  b y asFloat.	a _ b x * b x + (b y * b y) /16.0.	until (user yellowbug or user bluebug) do	[user redbug [p_user mp.		t _ b* (p-p2).		t _ (t x + t y /a) asInteger abs min: 16.		brush brush: p mode: mode color: vs(17-t)]	]	]' classified: 'As yet unclassified'BitRectTool understands: 'showon: butvec	[butvec1 setvalue: action.	butvec2 setvalue: tone.	butvec3 setvalue: mode.	butvec4 setvalue: pencil width.	butvec5 setvalue: grid]' classified: 'As yet unclassified'BitRectTool understands: 'tone	[ tone]' classified: 'As yet unclassified'RadioButtons understands: 'bug: pt | r a	[r _ (pt - rect origin - (11)) / size.	a _ r x + r y + 1.	self push: a]' classified: 'As yet unclassified'RadioButtons understands: 'classComment [	''A RadioButtons is a row or column of square regions ("buttons") on the display screen.  There is always exactly one button pushed.  (RadioButtons is a model of the station selection buttons on a car radio.)  The pushed button has a black box around it.  Each button has a value associated with it, which is returned when the button is pressed.  RadioButtons will not destroy a menu picture (BitRect) displayed in its area, but the RadioButtons has no knowledge of the picture.'']' classified: 'As yet unclassified'RadioButtons understands: 'has: pt [rect has: pt]' classified: 'As yet unclassified'RadioButtons understands: 'moveto: pt	[rect moveto: pt.	cur _ 0.	rect corner x  rect origin y]' classified: 'As yet unclassified'RadioButtons understands: 'push: a	[self release: cur thenPush: a.	vec(cur _ a)]' classified: 'As yet unclassified'RadioButtons understands: 'release: a thenPush: b | boxer offset	[a=b[]	offset _ [size=rect extent y[size0] 0size].	[a0[boxer _ Rectangle new origin: (offset*(a-1)+rect origin+1)				extent: sizesize-1.  boxer comp.  (boxer inset: 11) comp]].	b0[boxer _ Rectangle new origin: (offset*(b-1)+rect origin+1)				extent: sizesize-1.  boxer comp.  (boxer inset: 11) comp]]' classified: 'As yet unclassified'RadioButtons understands: 'reset [cur_0]' classified: 'As yet unclassified'RadioButtons understands: 'setvalue: v | i	["if value has been lost, set self to 1"	i_(vec find: v) max: 1.	self push: i.  i]' classified: 'As yet unclassified'RadioButtons understands: 'value [veccur]' classified: 'As yet unclassified'RadioButtons understands: 'vec [vec]' classified: 'As yet unclassified'RadioButtons understands: 'vec: vec at: r height: size	[rect _ r rect: r+ ((vec length  1)*size).	cur _ 0]' classified: 'As yet unclassified'RadioButtons understands: 'vec: vec at: r width: size	[rect _ r rect: r+ ((1  vec length)*size).	cur _ 0]' classified: 'As yet unclassified'