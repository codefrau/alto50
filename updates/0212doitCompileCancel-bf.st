'Make doit key work properly in inspectors. Add compile/cancel/undo/again keys'CodePane understands: 'cancel	[pared formerly 		[scrollBar hidewhile [self showing: pared formerly]]	frame flash]'CodePane understands: 'compile	[pared formerly  [		scrollBar hidewhile 			[user displayFlush.			selectorPane compile: pared contents 				[pared formerly: false]]]	pared flash]'CodePane understands: 'doit | listen sel result printer 	[scrollBar hidewhile 		[listen _ pared isListening.		sel _ pared selectRange.		pared unselect; fintype.		[sel empty  [pared selectLine. sel _ pared selectRange]].		result _ selectorPane execute: pared selectionAsStream for: self.		sel  pared selectRange  ["syntax error"]		sel _ sel stop + 1.		pared selectRange: (sel to: sel).		printer _ (String new: 100) asStream.		[listen  [pared selectToPrompt.				printer crtab: 1; print: result; cr; next_ 20; space]			printer space; print: result].		pared paste: printer contents.		listen or deselectAfterDoit 			[pared select: pared selectRange stop + 1]]]'CodePane understands: 'kbd | key	[key _ user kbck.	key = 130 or (pared isListening and key = 13) 		[user kbd. self doit]	key = 138 		[user kbd. self compile]	key = 165 		[user kbd. self cancel]	pared typing]'CodePane understands: 'yellowbug	[editmenu bug		= 1  [pared again];		= 2  [pared copyselection];		= 3  [pared cut];		= 4  [pared paste];		= 5  [self doit];		= 6  [self compile];		= 7  [pared undo];		= 8  [self cancel];		= 9  [self chooseAlignment];		= 10  [self chooseLineHeight]	]'TextImage understands: 'again | next 	[self unselect.	[self fintype  [Scrap _ Scrap text]].	next _ para findString: Deletion startingAt: c2.	next = 0  [frame flash]	c1 _ next.	c2 _ c1 + Deletion length.	self paste: Scrap]'TextImage understands: 'kbd | typed key del shift c	"For typing speed this processes all the keys already queued.	It returns when the queue is empty, or a special key was processed"	[c1 < c2 and self checklooks  []	typed _ Set new string: 16.	[begintypein  []	del _ Deletion.	Deletion _ self selection.	begintypein _ c1].	while [key _ user kbdnext. shift _ user shiftKey.	key] do		[key = bs 			[c1 < c2  [] "deleting selection happens below"			typed empty 				[c1 _ 1 max: c1 - 1.				begintypein _ begintypein min: c1]			typed skip: 1]		key = cut  [self copyselection] "because mapped to cmd-c"		key = paste 			[self replace: typed.			begintypein _ c1 _ c2.			self paste]		key = ctlw 			[ [typed empty  [] self replace: typed. typed reset. c1 _ c2].			c1 _ 1 max: c1 - 1.			while (c1 > 1 and (para  (c1 - 1)) tokenish) do				[c1 _ c1 - 1].			begintypein _ begintypein min: c1]		key = esc 			[ [typed empty  [] self replace: typed. typed reset. c1 _ c2].			self fintype.			c1 _ c2 - Scrap length.			self complement]		key = 167  "doit prompt"			[typed next_ 20; space]		key = all 			[[typed empty  [] self replace: typed].			self unselect. begintypein _ c1 _ 1. c2 _ para length + 1.			self select]		key = again 			[[typed empty  [] self replace: typed].			[begintypein = c1  [begintypein _ false. Deletion _ del]].			self again]		key = undo 			[self undo]		key = left 			[[typed empty  [] self replace: typed].			self cursorBackward c to c - 1 shift: shift]		key = right 			[[typed empty  [] self replace: typed].			self cursorForward c to c + 1 shift: shift].		key = up 			[[typed empty  [] self replace: typed].			self cursorBackward c to (self charofpt: (self pointofchar: c) - (0self lineheight)) shift: shift]		key = down 			[[typed empty  [] self replace: typed].			self cursorForward c to (self charofpt: (self pointofchar: c) + (0self lineheight)) shift: shift]		key = pageup 			[[typed empty  [] self replace: typed].			self cursorBackward c to (self charofpt: (self pointofchar: c) - (0window height)) shift: shift]		key = pagedown 			[[typed empty  [] self replace: typed].			self cursorForward c to (self charofpt: (self pointofchar: c) + (0window height)) shift: shift]		key = home 			[[typed empty  [] self replace: typed].			self cursorBackward c to [while (c > 1 and para(c-1)  cr) do [c _ c - 1]. c] shift: shift]		key = end 			[[typed empty  [] self replace: typed].			self cursorForward c to [while (c  para length and parac  cr) do [c _ c + 1]. c] shift: shift]		typed next_ key].	self replace: typed.	c1 _ c2.	self selectAndScroll]'TextImage understands: 'selectLine 	[ "Select back to CR or prompt, and forward to the end of the line or text"	c1 _ c2.	until (c1 = 1 or ((para(c1-1)=13) or: (para(c1-1)=20))) do		[c1 _ c1 - 1].	c2 _ para length+1 min: c1.	until (c2 = (para length+1) or parac2=13) do		[c2 _ c2 + 1]]'TextImage understands: 'selectToPrompt | c2s	[c2s _ c2.	"select until next prompt so we replace the old result"	while (c2  para length and para(c2-2)  20) do [c2 _ c2 + 1].	"if no prompt found, undo"	para(c2-2)  20  [c2 _ c2s]]'TextImage understands: 'undo 	[self unselect; fintype.	self replace: Deletion.	self complement]'TextImage derstands: 'doit:' unique.