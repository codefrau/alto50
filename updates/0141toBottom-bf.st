'Send window to bottom'Smalltalk declare: beTopWindow as: nil.Dispframe understands: 'showClipped: rect	[rect intersects: self frame  [self show]]'UserView understands: 'toBottom: w	[self unschedule: w; scheduleOnBottom: w; restore: w fullFrame]'Window understands: 'bluebug	[windowmenu bug		=1[exitflag _ false];		=2[self newframe; enter];		=3[self close. user unschedule: self. self restore. self leave. false];		=4[self style: noTitle _ (self style: noTitle)  false. user restore];		=5[self styleEdit];		=6[self forgetBits; leave; enter];		=7[self hardcopy];		=8[self print];		=9[self inspect]]'Window understands: 'classInit 	[border _ 2  2.	titleframe _ Textframe new para: nil frame: nil.	titleloc _ 3  (4 - titleframe lineheight).	titlerun _ String new: 2.	titlerun word: 1 _ 255.	(defaultStyle _ Dictionary new: 10)		insert: fill with: white;		insert: borderWidth with: 2;		insert: borderColor with: black.	windowmenu _ Menu new string: ''to bottomframeclosetoggle titleborder & fillrestoreprintprintbitsinspect'']'Window understands: 'clearTitle: color 	[self fullTitleFrame clear: color]'Window understands: 'firsttime 	[(frame has: user mp) or self  beTopWindow 		[self reset.		self enter.		user waitnobug]	false]'Window understands: 'fullFrame | rect	[rect _ frame.	[self style: noBorder  []	rect _ rect inset: 11 * (self style: borderWidth)].	rect _ rect include: self fullTitleFrame.	rect]'Window understands: 'fullTitleFrame | rect	[self style: noTitle  [frame origin rect: frame origin]	[self  user topWindow  [rect _ titleframe window]	rect _ frame origin - titleloc rect: frame maxX  frame minY].	rect inset: 2  2]'Window understands: 'restore	[user restore: self fullFrame without: self]'Window understands: 'showClipped: rect	[rect intersects: self fullFrame  [self show]]'UserView understands: 'restore: rect without: exclude| i w hideDisp	[kbMap _ NTkbMap.	noupdate _ true.	DisplayBLTer window: rect.	rect clear.	hideDisp _ self  self rootUserview.	for i from: sched length to: 1 by: 1 do		[(w _ schedi)  exclude  []		hideDisp and w  disp  []		w showClipped: rect].	DisplayBLTer window: screenrect.	noupdate _ false]'UserView understands: 'run: topFlag | i w forward	"topFlag means sched1 already is awake"	[forward _ [topFlag [w_sched1. while w eachtime do []. w lasttime] true].	while true do		[i_0.		[forward or sched length = 0  [beTopWindow _ nil]			self toBottom: w.			beTopWindow _ sched1].		until [(i_i+1) > sched length[]			w _ schedi.			w firsttime] do []		i>sched length		"check for bug in empty space"				[user yellowbug[self bugScreenMenu]]		sched promote: w.		while w eachtime do []		forward_ w lasttime]]'Window classInit