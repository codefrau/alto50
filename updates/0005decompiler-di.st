'Fix decompiler'Decompiler understands: 'decompile: t1 withMethod: method class: t2 | t3 t4 t5 t6 t7 t8 	[method length < [NoteTaker  [3]	8]  [self quickCode: t1 class: t2]	[NoteTaker 		[literals _ method literals.		t6 _ method primitive.		t7 _ method initialPC - 1.		t8 _ method numArgs + method numTemps]	literals _ MessageDict new literalsIn: method.	t6 _ method  2.	t7 _ method  6.	t8 _ method  5].	temps _ Vector new: t8.	self initSymbols: t2.	stack _ (Vector new: 10) asStream.	t4 _ self block: t7 + 1 to: method length pc [t5] hasValue [t5].	stack empty  false  [user notify: ''stack not empty'']	self convertMacros: t4 sel: t1.	t3 _ Stream default.	self printPattern: t1 on: t3.	t3 crtab: 1.	t4 printon: t3 indent: 1 precedence: 0 forValue: false decompiler: self.	[t6  0 		[t3 append: '' primitive: ''.		t3 print: t6]].	t3 contents asParagraph makeBoldPattern]' classified: 'As yet unclassified'ParsedBlock understands: 'printon: t1 indent: t2 precedence: t3 forValue: t4 decompiler: t5 | t6  	[position = 0  [t1 append: ''[]'']	[t3 = 5  [t1 append: ''('']].	t1 append: ''[''.	for t6 to: position - 1 do		[array  t6 printon: t1 indent: t2 precedence: 0 forValue: false decompiler: t5.		t1 append: ''.''.		t1 crtab: t2].	[returns  [t1 append: '''']].	array  position printon: t1 indent: t2 precedence: 0 forValue: (returns or t4) decompiler: t5.	t1 append: '']''.	t3 = 5  [t1 append: '')'']]' classified: 'As yet unclassified'ParsedBlock understands: 'quickCode | t1 t2 	[[position = 1 and (returns and [t2 _ array  1.	t2 emitsLoad]) 		[t2 = toLoadSelf 			[NoteTaker  [(CompiledMethod new: 2) toReturnSelf]			t1 _ String new: 2.			t1  1 _ 0.			t1  2 _ 1.			t1]		t2 isField 			[NoteTaker  [(CompiledMethod new: 2) toReturnField: (t2 land: 255) + 1]			t1 _ String new: 5.			t1  1 _ 0.			t1  2 _ 40.			t1  3 _ 0.			t1  4 _ 0.			t1  5 _ t2.			t1]		false]].	false]' classified: 'As yet unclassified'ParsedConditional understands: 'printon: t1 indent: t2 precedence: t3 forValue: t4 decompiler: t5 | t6 t7 	[[t3 > 0  [t1 append: ''['']].	ifExpr printon: t1 indent: t2 precedence: 0 forValue: true decompiler: t5.	t1 append: '' ''.	[thenExpr position > 1 or (thenExpr  1 is: ParsedConditional)  [t1 crtab: t2 + 1]	t1 space].	thenExpr printon: t1 indent: t2 + 1 precedence: 0 forValue: t4 decompiler: t5.	[elseExpr position = 1 and elseExpr last  nil  []	t1 crtab: t2.	t6 _ t1 position.	t7 _ t1 pop.	elseExpr printon: t1 indent: t2 precedence: 0 forValue: t4 decompiler: t5.	t1 skip: 1.	t1  t6 _ t7].	t3 > 0  [t1 append: '']'']]' classified: 'As yet unclassified'ParsedForLoop understands: 'printon: t1 indent: t2 precedence: t3 forValue: t4 decompiler: t5 	[source  nil 		[t1 append: ''for ''.		var printon: t1 indent: t2 precedence: 2 forValue: true decompiler: t5.		[start  toLoad1 and step  toLoad1  []		t1 append: '' from: ''.		start printon: t1 indent: t2 precedence: 2 forValue: true decompiler: t5].		t1 append: '' to: ''.		stop printon: t1 indent: t2 precedence: 2 forValue: true decompiler: t5.		[step  toLoad1  []		t1 append: '' by: ''.		step printon: t1 indent: t2 precedence: 2 forValue: true decompiler: t5].		t1 append: '' do''.		t1 crtab: t2 + 1.		doExpr printon: t1 indent: t2 + 1 precedence: 0 forValue: false decompiler: t5]	t1 append: ''for ''.	var printon: t1 indent: t2 precedence: 2 forValue: true decompiler: t5.	t1 append: '' from: ''.	source printon: t1 indent: t2 precedence: 2 forValue: true decompiler: t5.	t1 append: '' do''.	t1 crtab: t2 + 1.	doExpr printon: t1 indent: t2 + 1 precedence: 0 forValue: false decompiler: t5]' classified: 'As yet unclassified'ParsedMessage understands: 'printon: t1 indent: t2 precedence: t3 forValue: t4 decompiler: t5 | t6 t7 t8 t9 t10 t11 t12 t13  	[t6 _ t5 selector: op.	t10 _ [(t6  1) isletter  false  [3]			t6 iskeyword  [2]			4].	t9 _ t10 < t3 or (t10 = t3 and: t10 < 3).	[t9  [t1 append: ''('']].	t12 _ t1 position.	rcvr printon: t1 indent: t2 precedence: [rcvr is: ParsedBlock  [5]	t10] forValue: true decompiler: t5.	[t10 = 4 and: t6 last  ''_'' last 		[t1 space.		t1 append: t6]	t7 _ t6 keywords.	t11 _ [args  nil  [()]			args is: Vector  [args]			args inVector].	for t8 to: t7 length do		[t1 space.		t1 append: t7  t8.		t1 space.		t11  t8 printon: t1 indent: t2 precedence: [(t7  t8) last = ''_'' last  [1]		t10 = 3  [4]		t10] forValue: true decompiler: t5]].	[hasPC  [t5 highlight: (t12 + 1 to: t1 position + 1)]].	t9  [t1 append: '')'']]' classified: 'As yet unclassified'