Class new title: ShapeWindow	subclassof: Window	fields: ''	declare: 'CrossHairCursor ';	classified: 'Windows'Class new title: ArrowWindow	subclassof: ShapeWindow	fields: ''	declare: 'CrossHairCursor ';	classified: 'Windows'Class new title: EllipseWindow	subclassof: ShapeWindow	fields: ''	declare: 'CrossHairCursor ';	classified: 'Windows'Class new title: RectWindow	subclassof: ShapeWindow	fields: ''	declare: '';	classified: 'Windows'ArrowWindow understands: 'default | pt	[self crossHairCursor showwhile [pt _ user waitbug].	self style: beginPoint _ pt.	self style: endPoint _ pt.	self style: hasHead _ true.	frame _ (pt rect: pt) inset: 2020.	self pointMove: endPoint]'ArrowWindow understands: 'fixPoint: pt of: whichPt | other	[user shiftKey  [		[whichPt = beginPoint  [			other _ style  endPoint]		other _ style  beginPoint].		[(other x - pt x) abs > (other y - pt y) abs  [			 pt x  other y]		 other x  pt y]]	 pt]'ArrowWindow understands: 'updateFrame	[ (Rectangle new encompass: self beginPoint, self endPoint) inset: 2020]'EllipseWindow understands: 'default | rect	[	rect _ Rectangle new fromuser.	self style: centerPoint _ rect center.	self style: topPoint _ rect center x  rect origin y.	self style: rightPoint _ rect corner x  rect center y.	self style: fill _ nil.	frame _ rect inset: 2020]'EllipseWindow understands: 'draw: function | t top right c i r p ext2	[	top _ self style: topPoint.	right _ self style: rightPoint.	c _ self style: centerPoint.	ext2 _ (right x - c x)  (c y - top y).	t _ Turtle init.	t batch: true.	[nil  function  [t function_ function]].	t width: (self style: borderWidth).	t color: (self style: borderColor).	i _ 0.	while i  360 do [		r _ i asFloat / 180.0 * 3.1415926.		p _ r cos  r sin.		p _ (p x * ext2 x asFloat)  (p y * ext2 y asFloat).		p _ p + c.		[i = 0  [t place: p]			t goto: p].		i _ i + 5]]'EllipseWindow understands: 'eachtime	[(self pointHotspot: stylecenterPoint) has: user mp		 [self crossHairCursor showwhile [self pointMove: centerPoint]. true].	(self pointHotspot: stylerightPoint) has: user mp		 [self crossHairCursor showwhile [self pointMove: rightPoint]. true].	(self pointHotspot: styletopPoint) has: user mp		 [self crossHairCursor showwhile [self pointMove: topPoint]. true].	super eachtime]'EllipseWindow understands: 'fixPoint: pt of: whichPt | other	[	whichPt = centerPoint  [		self style: topPoint _ (self style: topPoint) + pt - (self style: centerPoint).		self style: rightPoint _ (self style: rightPoint) + pt - (self style: centerPoint).		 pt]	whichPt = topPoint  [		 (self style: centerPoint) x  pt y].	whichPt = rightPoint  [		 pt x  (self style: centerPoint) y].	 pt]'EllipseWindow understands: 'updateFrame | tl c br	[c _ self style: centerPoint.	tl _ c x - ((self style: rightPoint) x - c x)  (self style: topPoint) y.	br _ (self style: rightPoint) x  (c y + (c y - (self style: topPoint) y)).	 (tl rect: br) inset: 2020]'RectWindow understands: 'default | pt	[self crossHairCursor showwhile [pt _ user waitbug].	user show: pt asString; cr.	self style: beginPoint _ pt.	self style: endPoint _ pt.	self style: fill _ nil.	frame _ (pt rect: pt) inset: 2020.	self pointMove: endPoint]'RectWindow understands: 'draw: function | t fill b e	[	b _ self style: beginPoint.	e _ self style: endPoint.	fill _ self style: fill.	[nil = fill  [self restore]	(b rect: e) clear: fill].	t _ Turtle init.		t batch: true.	[nil  function  [t function_ function]].	t width: (self style: borderWidth).	t color: (self style: borderColor).	t place: b.	t goto: b x  e y.	t goto: e.	t goto: e x  b y.	t goto: b]'RectWindow understands: 'eachtime	[(self pointHotspot: stylebeginPoint) has: user mp		 [self crossHairCursor showwhile [self pointMove: beginPoint]. true].	(self pointHotspot: styleendPoint) has: user mp		 [self crossHairCursor showwhile [self pointMove: endPoint]. true].	super eachtime]'RectWindow understands: 'updateFrame | b e	[b _ (self style: beginPoint) min: (self style: endPoint).	e _ (self style: beginPoint) max: (self style: endPoint).	self style: beginPoint _ b.	self style: endPoint _ e.	 (b rect: e) inset: 2020]'ShapeWindow understands: 'clearCursor	[CrossHairCursor _ nil]'ShapeWindow understands: 'crossHairCursor 	[CrossHairCursor  nil  [CrossHairCursor]	CrossHairCursor _ (Cursor new fromtext: ''0000001111000000000000111100000000000011110000000000001111000000000000111100000000000011110000001111110000111111111111000011111111111100001111111111110000111111000000111100000000000011110000000000001111000000000000111100000000000011110000000000001111000000'' offset: 0  0).	CrossHairCursor]'ShapeWindow understands: 'enter	[self show]'ShapeWindow understands: 'fixPoint: pt of: whichPt	[ pt]'ShapeWindow understands: 'outside	[false]'ShapeWindow understands: 'pointHotspot: pt	[pt asRectangle inset: 1010]'ShapeWindow understands: 'pointMove: whichPt | hotspot current other	[hotspot _ self pointHotspot: stylewhichPt.	until user anybug do		[(hotspot has: user mp)  false  [false]].	self restore; draw: xoring.	while user anybug do [		current _ user mp.		current _ self fixPoint: user mp of: whichPt.		self draw: xoring.		style  whichPt _ current.		self draw: xoring.	].	self draw: xoring.	self frame: self updateFrame.	self show]'ShapeWindow understands: 'show	[self draw: storing]'ShapeWindow understands: 'updateFrame	[ frame]'UserView understands: 'bugScreenMenu | m w turtle i f index file	[m _ 0.	screenMenu bug	= (m_m+1)  [projectWindow runParent];	= (m_m+1)  [projectSequencer visitNext];	= (m_m+1)  [self restore];	= (m_m+1)  [self schedule: ProjectWindow init];	= (m_m+1)  [self schedule: ProjectSorter init];	= (m_m+1)  [self schedule: BrowseWindow default];	= (m_m+1)  [self schedule: (CodeWindow new class: UserView selector: workspace para: (UserView code: workspace) formerly: false)];	= (m_m+1)  [w _ self loadFormWindow  [self schedule: w enter]];	= (m_m+1)  [user schedule: (ArrowWindow new default)];	= (m_m+1)  [user schedule: (RectWindow new default)];	= (m_m+1)  [user schedule: (EllipseWindow new default)];	= (m_m+1)  [self schedule: (D1TopWindow new default)];	= (m_m+1) 		[turtle _ Turtle init.		turtle color: black; width: 4; inking: oring.		for i to: 50 do [turtle go: i * 4; turn: 89]];	= (m_m+1) 		[f _ self fileMenu: ''edit'' directory: '''' matching: ''*''			 [self editFile: f]];	= (m_m+1) 		[f _ self fileMenu: ''file in'' directory: '''' matching: ''*.st''			 [self filin: f]];	= (m_m+1) 		[f _ self fileMenu: ''file delete'' directory: '''' matching: ''*''			 [self confirm: ''Really delete '' + f  [self fileString: f _ nil]]];		= (m_m+1) 		[f _ self fileMenu: ''publish'' directory: '''' matching: ''*.st''			 [file _ self fileString: f.			self fileString: (self update: f _ file) _ file.			self fileString: f _ nil]];	= (m_m+1)  [self loadUpdates];	= (m_m+1)  [user save]]'UserView understands: 'classInit 	[screenMenu _ Menu new string:''go to parent projectgo to next projectrestore displayopen a projectopen a project sorteropen a browseropen a workspaceopen form ...create an arrowcreate a rectanglecreate an ellipsetablet demoturtle demoedit file ...file in ...delete file ...publish update ...load updatessave'']'ArrowWindow derstands: 'clearCursor' unique.ArrowWindow derstands: 'crossHairCursor' unique.ArrowWindow derstands: 'draw' unique.ArrowWindow derstands: 'enter' unique.ArrowWindow derstands: 'outside' unique.ArrowWindow derstands: 'pointHotspot:' unique.ArrowWindow derstands: 'pointMove:' unique.ArrowWindow derstands: 'show' unique.ArrowWindow derstands: 'theta:' unique.ArrowWindow derstands: 'undraw' unique.ShapeWindow derstands: 'fixPoint:' unique.UserView classInit