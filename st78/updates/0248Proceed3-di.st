Class understands: 'edit: selector para: para formerly: oldpara	[user leaveTop.	user schedule: (CodeWindow new class: self selector: selector para: para formerly: oldpara)]' classified: 'as yet unclassified'CompiledMethod understands: 'bytes 	[self isQuick  ['''']	 (Stream new of: self from: self initialPC to: self length)		rest asBytes]' classified: 'as yet unclassified'NotifyWindowNT understands: 'closeAndUnschedule	[super closeAndUnschedule.	thisContext restart]' classified: 'as yet unclassified'Object understands: 'inspect 	[user leaveTop.	user schedule: (InspectWindow new of: self)]' classified: 'user interface'Parser understands: 'from: sourceStrm to: compiler | parserProcess 	[source _ sourceStrm.	dest _ compiler.	oppositeCourt _ thisContext.	parserProcess _ Process new: 1000.	parserProcess init.	parserProcess send: begin to: self.	parserProcess eval]' classified: 'as yet unclassified'Process understands: 'bounceBackTest: originalProcess | p	"Set up and run a process that simply resumes this one.	Should print a process oop and immediately resume,	so that printing thisContext asOop yields the same result 	before and after -	| p .  p _ Process new: 1000.	p init.	p send: bounceBackTest: to: p withArgs: thisContext inVector.	p eval.	"	[user cr; show: ''Running ''; print: thisContext asOop.	originalProcess eval]' classified: 'as yet unclassified'Process understands: 'pop | topIndex value	["Notetaker stack grows down"	topIndex _ self length - top.	value _ self  topIndex.	top _ top - 1.	 value]' classified: 'as yet unclassified'Process understands: 'popN: nToPop   "No return value"	[top _ top - nToPop]' classified: 'as yet unclassified'Process understands: 'push: obj | topIndex 	[top _ top + 1.	"Notetaker stack grows down"	topIndex _ self length - top.	 self  topIndex _ obj]' classified: 'contexts'Process understands: 'send: selector to: rcvr withArgs: args | method mclass a i	[mclass _ rcvr class.	until (mclass md has: selector) do		[mclass _ mclass superclass.		mclass  nil  [user notify: ''message not understood:'' + selector]].	args length  selector numArgs		[self error: ''numArgs mismatch''].	"One basic stack frame - - -"	for a from: args do [self push: a].	self push: rcvr.	self push: mclass.	method _ mclass method: selector.	self push: method.	self push: method numArgs.	self push: 0.  "caller PC and BP undefined"	self push: 0.	"One basic stack frame - - -"	for i to: method numTemps do [self push: nil].	"End of basic stack frame - - -"	self push: method initialPC + 1.	self push: 1+method numTemps]' classified: 'as yet unclassified'Process understands: 'send: selector to: rcvr 	[ self send: selector to: rcvr withArgs: ()]' classified: 'as yet unclassified'Process understands: 'topIndex	[ self length - top]' classified: 'as yet unclassified'Process understands: 'topIndex_ index	["NT stack grows down from end"	top _ self length - index]' classified: 'as yet unclassified'ProcessFrame understands: 'process	[ process]' classified: 'as yet unclassified'ProcessFrame understands: 'resume: mode with: proceedValue | succ myStack pcToResume oldProcessTop i	["First find the successor frame.	The bottom of that frame is top of this stack.	So at that point we want to push a PCBP pair to restart,	or push a reply plus a PCBP pair to proceed."		succ _ self successor.		pcToResume _ succ callerPC+1.		myStack _ succ bp + 5. "points to rcvr"		oldProcessTop _ process topIndex.	[mode = ''restart''		[process topIndex_ self bp.		for i to: self method numTemps do [process push: nil].		pcToResume _ self method initialPC].	mode = ''resume''		[process topIndex_ myStack.		process popN: self nargs+1. "pop rcvr and args"		process push: proceedValue.		].	mode = ''interruprt''		[user notify: ''unser construction''].	].	process push: pcToResume+1.  "VM offset from ST pc index"	process push: self bp - process topIndex.	"nil out everything from myStack to process top."	for i from: process topIndex+1 to: oldProcessTop do		[processi _ nil].	process eval]' classified: 'as yet unclassified'ProcessFrame understands: 'successor | limit pi 	["Crawl forward in the stack looking for the next viable processFrame"	limit _ process topIndex.	pi _ bp - 1.  "Process index"	while pi  limit do		[[process  (pi + dOffsetBPDelta) is: Integer 			[process  (pi + dOffsetBPDelta) = (bp - pi - 1) 				[process  (pi + dOffsetCallersPC) is: Integer 					[process  (pi + dOffsetNrArgs) is: Integer 						[process  (pi + dOffsetMethod) is: CompiledMethod 							[process  (pi + dOffsetMethodClass) is: Class  [ProcessFrame new process: process bp: pi]]]]]]].		pi _ pi - 1].	nil]' classified: 'linked frames'StackPane understands: 'classInit   "StackPane classInit."	[stackmenu _ Menu new string:''proceedrestartdebugclose'']' classified: 'as yet unclassified'StackPane understands: 'continue: restart | frameToRun restartProcess myWindow	["By starting another process, we cause this one to externalize the VM state.	This allows us to tweak that state so that when it resumes, it will	either resume or restart at the currently selected processFrame."	"Note: proceed1 means from an interrupt	and proceed2 is a value to be returned when proceeding.	proceed3 is for interrupt level when running in a processScheduler."	[selection = 0  [selection _ 1]].	frameToRun _ list  selection.	restartProcess _ Process new: 1000.	restartProcess init.	restartProcess send: resume:with: to: frameToRun withArgs: ([restart[''restart''] ''resume'']), (proceed2).	myWindow _ user topWindow.	user unschedule: myWindow.	myWindow restore.	restartProcess eval]' classified: 'as yet unclassified'StackPane understands: 'yellowbug	[scrollBar hidewhile		[stackmenu bug			=1 ["proceed in selected context" self continue: false];			=2 ["restart selected context" self continue: true];			=3 [user shiftKey[self inspect "- for Dan"].				"debug - show code and inspectors"				(user topWindow) restore; newframe; enter];			=4 [user topWindow closeAndUnschedule]]]' classified: 'as yet unclassified'SymbolTable understands: 'allCallsOn: selectors	[ self allCallsOn: selectors from self allClassNames]' classified: 'as yet unclassified'SymbolTable understands: 'allCallsOn: selectors from: classNames | cName strm callers class sel  	"selectors is a UniqueString or a vector of same.	classNames is usually Smalltalk allClassNames"	[[selectors is: Vector  []	selectors _ selectors inVector].	strm _ Stream default.	user displayoffwhile 		[for cName from: classNames do			[class _ self  cName.			for sel from: selectors do				[callers _ class whosends: sel.				callers length = 0  []				strm append: cName.				strm append: ''''.				strm append: callers.				strm cr]]].	strm contents]' classified: 'as yet unclassified'SymbolTable understands: 'allRefsTo: nameOrNames  "Smalltalk allRefsTo: Process"	[self allRefsTo: nameOrNames from: self allClassNames]' classified: 'as yet unclassified'Array derstands: 'aTest' unique.Array derstands: 'aTest' unique.Array derstands: 'aTest1' unique.NotifyWindowNT derstands: 'close' unique.Process derstands: 'topFrame' unique.RemoteCode derstands: 'toProceedFrom:' unique.RemoteCode derstands: 'toRestartFrom:' unique.StackPane derstands: 'close' unique.StackPaneNT derstands: 'close' unique.SymbolTable derstands: 'allRefs' unique.StackPane classInit