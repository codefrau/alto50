'Always use oring when rendering text - helps with mixed small/large fonts. Plus minor other fixes (menu, ticks)'D1TextPane understands: 'handleClick: p	[pared select: (pared charofpt: p)]'Menu understands: 'stringFromVector: vec | item stream  	[stream _ Stream default.	for item from: vec do		[stream append: [item is: String  [item] item asString]; cr].	self string: stream contents]'Textframe understands: 'charofpoint: pt andrect rect | line leftx rightx y chari scanner pos r 	[line _ 0 max: (self lineofy: pt y).	y _ self yofline: line.	[line = 0 		[chari _ 1. pos _ frame minX(y + style lineheight)]	"else"		pt y  (y + style lineheight) 			[self pointofchar: para length + 1 andrect [r].			rect value_ r.			para length + 1]		scanner _ self printer: false.		scanner scanline: linesline at: y stopx: pt x stopchar: (linesline) stopi.		chari _ scanner chari.		rightx _ scanner rightx.		leftx _ scanner leftx.		pt x  (leftx + rightx / 2) or parachari = cr 				[pos _ leftxy]			chari _ chari + 1.			pos _ rightxy].	rect value_ pos extent: 0style lineheight.	chari]'TextScanner understands: 'scanline: line at: lineY stopx: sx stopchar: stopChar | nullChar xOfLastSpace stopCode emphasis runAndVal endOfRun padding relX tabsize spacePad alignment	[stopx _ sx.	chari _ line starti - 1.	spacecount _ line spaces.	padding _ line padwidth.	destx _ spacex _ xOfLastSpace _ frame minX.	spacePad _ charpad _ emphasis _ 0.	tabsize _ style tabsize.	spacei _ 1.	[printing  [desty _ lineY. width _ frame maxX - destx. height _ style lineheight.		function _ 28. self callBLT]].	alignment _ para alignment.	[alignment = 0 "left"  []	alignment = 1 "justify" 		[spacecount > 0 			[charpad _ padding / (line stopi - chari + spacecount).			[charpad > 0 				[padding _ padding - (charpad * (line stopi - chari - 2 - spacecount))]].			spacePad _ padding / spacecount.			spacecount _ spacecount - (padding \ spacecount)]]	alignment = 2 "center"  [destx _ destx + (padding / 2)]	alignment = 4 "right"  [destx _ destx + padding]].	stopCode _ 10.	until stopCode < 10 do		[stopCode = 10 			[stopCode _ 255.			chari  stopChar  [stopCode _ 3]			[printing  [self emphasize: emphasis leftx: xOfLastSpace rightx: destx liney: lineY]].			xOfLastSpace _ destx.			chari _ chari + 1.			runAndVal _ para runAndVal: chari.			emphasis _ runAndVal2 land: 15.			endOfRun _ runAndVal1 + chari - 1 min: stopChar.			self setfont: (runAndVal2 lshift: 4) liney: lineY]		stopCode _ self scanword: endOfRun.		stopCode > 10 			[[stopCode = 12  "space"				[spacecount _ spacecount - 1.				[spacecount = 0  [spacePad _ spacePad + 1]].				spacei _ chari.				spacex _ destx.				width _ spacesize + spacePad]			stopCode = 13  "tab"				[relX _ destx - frame minX.				width _ [para alignment > 0  [tabsize + charpad]						relX + tabsize | tabsize - relX]]			[stopCode = 11  [nullChar _ maxascii + 1]].			sourcex _ xtable(nullChar + 1).			width _ xtable(nullChar + 2) - sourcex.			[printing 				[function _ 17.				self callBLT]].			width _ width + charpad].			destx _ destx + width.			destx > stopx  [stopCode _ 2]			chari  endOfRun  [stopCode _ 10]			chari _ chari + 1]		stopCode = 4  [width _ 0]].	printing  [self emphasize: emphasis leftx: xOfLastSpace rightx: destx liney: lineY]]'TextScanner understands: 'scanword: lasti | ascii w	[function _ 17.	until chari > lasti do		[ascii _ text  chari.		exceptions  (ascii + 1)  0  [exceptions  (ascii + 1)]		ascii < minascii or ascii > maxascii  [11]		sourcex _ xtable  (ascii + 1).		width _ xtable  (ascii + 2) - sourcex.		[printing  [self callBLT]].		[kern > 0 				[w _ width + charpad - kern.				w < 2  [w _ 2]]			w _ width + charpad].		destx _ destx + w.		destx > stopx  [2]		chari _ chari + 1].	chari _ chari - 1.	10] primitive: 50'UserView understands: 'runTicks	["Run through the scheduler sending tick to any window with style: ticking"	"This is experimental and may foul up our nice throttling of CPU cycles"	"I apologize in advance for using a class variable for tickIndex."	"Runs at most one window tick per call on idle"	[tickIndex  nil  [tickIndex _ 1]	 tickIndex _ tickIndex + 1.	 tickIndex  sched length  [tickIndex _ 1]].	while tickIndex  sched length do		[(schedtickIndex) style: ticking  [ (schedtickIndex) tick]		user buttons. "indicate to VM that we are in fact idle"		tickIndex _ tickIndex + 1]	]'Textframe derstands: 'charofpoint:' unique.