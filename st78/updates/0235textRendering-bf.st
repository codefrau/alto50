'Fix rendering mixed-font text. Make emph keys toggle. Paste preserves emphasis.'CodePane understands: 'chooseLineHeight  | lineheight	[lineheight _ pared style lineheight.	(Menu new string: ''+ 10+ 5+ 3+ 2+ 1lineheight='' + lineheight asString + ''- 1- 2- 3- 5- 10'') bugButtonUp		= 1  [pared lineheight _ lineheight+10; show];		= 2  [pared lineheight _ lineheight+5; show];		= 3  [pared lineheight _ lineheight+3; show];		= 4  [pared lineheight _ lineheight+2; show];		= 5  [pared lineheight _ lineheight+1; show];		= 6  [pared lineheight _ lineheight; show];		= 7  [pared lineheight _ lineheight-1; show];		= 8  [pared lineheight _ lineheight-2; show];		= 9  [pared lineheight _ lineheight-3; show];		=10  [pared lineheight _ lineheight-5; show];		=11  [pared lineheight _ lineheight-10; show]]'StyleSheet understands: 'lineheight: h linelead: l baseline: b 	[lineheight _ h.	linelead _ l.	baseline _ b]'Textframe understands: 'displayall | y	[y _ self displaylines: 1 to: lastline.	self clearfrom: y]'Textframe understands: 'displaylines: first to: last | rect a d h scanner y i line	[first _ first max: (self lineofy: window minY).	last _ last min: (self lineofy: window maxY).	rect _ window minX(self yofline: first) rect: window maxX((self yofline: last) + style lineheight).	if style linelead < 0 then		"render additional lines if they overlap"		[self maxAscent a andDescent d.		h _ a - style baseline max: style baseline + d - style lineheight.		first _ first - (h / style lineheight + 2) max: 1.		last _ last + (h / style lineheight + 2) min: lastline.		rect origin y _ rect origin y - h.		rect corner y _ rect corner y + h - style lineheight].	(rect intersect: window) clear: white.	scanner _ self printer: true.	y _ self yofline: first.	for i from: first to: last do		[line _ lines  i.		scanner scanline: line at: y stopx: window maxX stopchar: line stopi.		y _ y + style lineheight].	y]'Textframe understands: 'lineheightAdjust | i f "adjust baseline and linelead after font change"	[para length = 0  []	f _ para runs2 land: 240.	for i from: 4 to: para runs length by: 2 do [		f  (para runsi land: 240)  [f _ false]].	"if there is only a single font, use its height. Otherwise, preserve current"	self lineheight _ [f  [(style font: f/16) height] self lineheight]]'Textframe understands: 'lineheight_ h | b l i a d font	[h _ h max: 4.	style _ style copy.	b _ style baseline + h - style lineheight. "default is keep old"	l _ style linelead.	if para length > 0 then [ "set baseline to center tallest font in line"		self maxAscent a andDescent d.		l _ h - a - d.		b _ (a + (h-a/2 max: 0) min: (h - d max: a)) min: h - (style font: 1) descent].	style lineheight: h linelead: l baseline: b]'Textframe understands: 'maxAscent ascBlock andDescent dscBlock | i font ascent descent	[if para length = 0	then [ascent _ style baseline.		descent _ style lineheight - style linelead - ascent]	else [ascent _ descent _ 0.		for i from: 2 to: para runs length by: 2 do [			font _ style fontset  ((para runsi land: 240) / 16).			ascent _ ascent max: font ascent.			descent _ descent max: font descent]].	ascBlock value _ ascent.	dscBlock value _ descent]'Textframe understands: 'replace: i1 to: i2 with: s | newl1 newl2 l l1 l2 oldLast line delta done oldlines index y1 y2 end 	[para replace: i1 to: i2 by: s.	lastline = 0 		[self measureall.		self displayall]	oldlines _ lines copy.	oldLast _ lastline.	l1 _ self lineofchar: i1.	newl1 _ l1.	l2 _ self lineofchar: i2.	delta _ s length - (i2 - i1 + 1).	index _ (lines  newl1) starti.	[l1 > 1 		[line _ self measurefrom: (lines  (l1 - 1)) starti to: para length.		lines  (l1 - 1) = line  []		l1 _ l1 - 1.		self line: l1 _ line.		index _ line stopi + 1]].	[index > para length 		[self trimLinesTo: (newl1 - 1 max: 0).		para length = 0 			[window clear: white.			self]]].	done _ false.	newl2 _ l2.	until (done or index > para length) do		[line _ self measurefrom: index to: para length.		self line: newl1 _ line.		until (done or (newl2 > oldLast or [i2 _ (oldlines  newl2) stopi + delta.		line stopi < i2])) do			[i2 = line stopi 				[y2 _ self yofline: newl2 + [delta < 0  [0] 1].				y1 _ self yofline: newl1 + [delta < 0  [0] 1].				l2 _ newl1.				done _ true.				end _ oldLast.				newl2 _ newl2 + 1.				l _ newl2 - 1.				while [l _ 1 + l.				end  l] do					[newl1 _ newl1 + 1.					self line: newl1 _ oldlines  l slide: delta].				self trimLinesTo: newl1]			newl2 _ newl2 + 1].		index _ line stopi + 1.		newl1 _ newl1 + 1].	[index > para length 		[l2 _ newl1 min: lastline.		self displaylines: l1 to: l2]	(frame minX  y2 rect: window corner) blt: frame minX  y1 mode: storing clippedBy: window.	self displaylines: l1 to: l2.	y1 < y2 and (self yofline: oldLast + 1) > window maxY 		[l2 _ self lineofy: window maxY.		self displaylines: (self lineofy: window maxY - (y2 - y1)) to: l2]].	oldLast  lastline  [self clearfrom: (self yofline: lastline + 1)]]'TextImage understands: 'checklooks | t val mask oldval leading [	"see ParagraphEditor checklooks.	substitute c1 for loc1, c2 for loc2, oldEntity for oldpara, entity for para"	t _ (166 150 137 151   230 214 201 215		135 159 144 143 128 127 129 131 180 149		199 223 208 207 192 191 228 229) find: user kbck.	t=0[false]	user kbd.	oldval _ (para runAndVal: c1)  2.	val _ (1 2 4 256   1 2 4 256  "ctl-b i - x   B I  X"		0 16 32 48 64 80 96 112 128 144  "ctl-0 1 ... 9"		160 176 192 208 224 240 01F0H 0110H)t.  "ctl-shift-0 1 ... 5 + -"	[val=256[mask_ 0377.  val_ 0]		"reset all"	val<0[mask_ 0-val.  val_ 0]		"reset emphasis"	val>0 and val<16[mask_ val.		"toggle emphasis"		(oldval land: mask)=val[val _ 0]]	mask_ 0360.					"set font"	val>240  [val _ oldval + val]].		"inc/dec font"	para maskrun: c1 to: c2-1 under: mask to: val.	if mask = 0360	then [self lineheightAdjust; show.		"self replace: c1 to: c2 - 1 with: (para copy: c1 to: c2 - 1)"]	else [self displaylines: (self lineofchar: c1) to: (self lineofchar: c2)].	self select]'TextImage understands: 'fixframe: f | dy  [	dy _ [framenil [0] self frameoffset].	window _ f copy.	frame _ Rectangle new origin: window origin + (2dy)		 extent: window width-4  9999.	self measureall.	window]'TextImage understands: 'paste | clip	[clip _ self primClipboard.	[(Scrap is: Paragraph) and (Scrap text = clip)  []	Scrap _ clip asParagraph].	self paste: Scrap]'TextScanner understands: 'emphasize: code leftx: leftX rightx: rightX liney: lineY | y y2 	[code = 0  []	"codes: 8=strikeout, 4=underline, 2=italic, 1=bold"	if code  8 then		[code _ code - 8.		y _ lineY + (style baseline / 2).		(leftX  y rect: rightX  (y + 1)) clear: black].	if code  4 then		[code _ code - 4.		y _ lineY + style baseline.		(leftX  y rect: rightX  (y + 1)) clear: black].	if code  2 then		[code _ code - 2.		y _ lineY + style lineheight - 4.		until y  lineY do			[(leftX  lineY rect: rightX - 1  y) blt: leftX + 1  lineY mode: storing.			(leftX  lineY rect: leftX + 1  y) clear: white.			y _ y - 4]].	if code  1 then		[code _ code - 1.		(leftX  lineY rect: rightX  (lineY + style lineheight)) blt: leftX + 1  lineY mode: oring]]'TextScanner understands: 'scanline: line at: lineY stopx: sx stopchar: stopChar | nullChar xOfLastSpace stopCode emphasis runAndVal endOfRun padding relX tabsize spacePad alignment	[stopx _ sx.	chari _ line starti - 1.	spacecount _ line spaces.	padding _ line padwidth.	destx _ spacex _ xOfLastSpace _ frame minX.	spacePad _ charpad _ emphasis _ 0.	tabsize _ style tabsize.	spacei _ 1.	if printing then [function _ 17].	alignment _ para alignment.	[alignment = 0 "left"  []	alignment = 1 "justify" 		[spacecount > 0 			[charpad _ padding / (line stopi - chari + spacecount).			[charpad > 0 				[padding _ padding - (charpad * (line stopi - chari - 2 - spacecount))]].			spacePad _ padding / spacecount.			spacecount _ spacecount - (padding \ spacecount)]]	alignment = 2 "center"  [destx _ destx + (padding / 2)]	alignment = 4 "right"  [destx _ destx + padding]].	stopCode _ 10.	until stopCode < 10 do		[stopCode = 10 			[stopCode _ 255.			chari  stopChar  [stopCode _ 3]			if printing then [self emphasize: emphasis leftx: xOfLastSpace rightx: destx liney: lineY].			xOfLastSpace _ destx.			chari _ chari + 1.			runAndVal _ para runAndVal: chari.			emphasis _ runAndVal2 land: 15.			endOfRun _ runAndVal1 + chari - 1 min: stopChar.			self setfont: (runAndVal2 lshift: 4) liney: lineY]		stopCode _ self scanword: endOfRun.		stopCode > 10 			[	[stopCode = 12  "space"					[spacecount _ spacecount - 1.					[spacecount = 0  [spacePad _ spacePad + 1]].					spacei _ chari.					spacex _ destx.					width _ spacesize + spacePad]				stopCode = 13  "tab"					[relX _ destx - frame minX.					width _ [para alignment > 0  [tabsize + charpad]							relX + tabsize | tabsize - relX]]				stopCode = 11  "no glyph"					[nullChar _ maxascii + 1.					sourcex _ xtable(nullChar + 1).					width _ xtable(nullChar + 2) - sourcex.					if printing then [self callBLT].					width _ width + charpad]].			destx _ destx + width.			destx > stopx  [stopCode _ 2]			chari  endOfRun  [stopCode _ 10]			chari _ chari + 1]		stopCode = 4  [width _ 0]].	printing  [self emphasize: emphasis leftx: xOfLastSpace rightx: destx liney: lineY]]'TextScanner understands: 'setfont: f liney: y 	[f = fontno  [desty _ y + style baseline - font ascent]	fontno _ f.	font _ style font: fontno.	xtable _ font xtable.	spacesize _ font spacewidth.	minascii _ font minascii.	maxascii _ font maxascii.	kern _ font kern.	[kernnil[kern _ 0]].	self sourceFont _ font.	printing 		[desty _ y + style baseline - font ascent.		height _ font height]]'StyleSheet derstands: 'lineheight:baseline:' unique.Textframe derstands: 'displayline:at:' unique.