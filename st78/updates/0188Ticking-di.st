ArrowWindow understands: 'tick  | time lastTick beginPoint angle pi2	["Do nothing unless at least 250 ms has elapsed since last tick"	lastTick_ self style: lastTick.	time _ user ticks.	lastTickfalsefalse and time<(lastTick+250)  [].	self style: lastTick _ time.	beginPoint _ self style: beginPoint.	beginPoint  false  ["oops not initialized for some reason"].	"increment angle, update endPoint and draw"	angle _ self style: angle.	[anglefalse[angle_ 0.0]]. 	pi2 _ Floatpi*2.0.	angle _ angle + (pi2/10.0).	[angle  (pi2*2.0) [angle _ angle - (pi2*2.0)] ].	self style: borderColor _ [angle  pi2 [white] black].	self style: angle _ angle.	self style: endPoint _ beginPoint + (angle asDirection*50).	self draw: 0]'Form understands: 'captureDisplay  | br	[br _ BitRect new title: ''BitRect'' in: self frame.	br saveScreenBits.	br copyToForm: self at: 00.	]'FormWindow understands: 'frame: f 	[[turtlemodetrue and f extent form extent		[form _ Form new extent: f extent]].	super frame: f]'FormWindow understands: 'leave 	[[turtlemodetrue[self captureDisplay]].	super leave]'Menu understands: 'bugit: buttonUpOK | t1 t2 	[	[buttonUpOK[user waitbug]		user nobug  [0]].	thisline comp.	while true do		[t1 _ user mp.		text frame has: t1 			[user anybug 				[thisline has: t1  [user idle]				t1 _ text ptofpt: t1.				thisline comp.				thisline moveto: text frame origin x  t1 y.				thisline comp]			1 + (thisline origin y - text frame origin y / text lineheight)]		thisline comp.		until (text frame has: user mp) do			[user nobug  [0].			user idle].		thisline comp]]'Object understands: 'startup 	[self firsttime 		[while self eachtime do			[user idle].		self lasttime]	false]'ScrollBar understands: 'eachtime | t1 t2 t3 	[t1 _ user mp.	rect has: t1 		[t2 _ rect center x - 2.		t1 x < t2 			[t3 _ Rectangle new origin: rect origin corner: t2  rect maxY.			DownCursor showwhile 				[while [t1 _ user mp.				t3 has: t1] do					[self slide: t1  [owner scrollTo: (position minY - rect minY - 4) asFloat / (rect height - 12)]					user redbug  [self reposition 							[owner scrollUp: rect origin y - t1 y.							user waitnobug]]					user idle].				nil]]		t3 _ Rectangle new origin: t2  rect minY corner: rect corner.		UpCursor showwhile 			[while [t1 _ user mp.			t3 has: t1] do				[self slide: t1  [owner scrollTo: (position minY - rect minY - 4) asFloat / (rect height - 12)]				user redbug  [self reposition 						[owner scrollUp: t1 y - rect origin y.						user waitnobug]]				user idle].			nil]]	false]'ScrollBar understands: 'slide: t1 | t2 	[position has: t1 		[JumpCursor showwhile 			[t2 _ false.			while ((position has: user mp) and t2  false) do				[user redbug 					[t2 _ true.					while user redbug do						[self reshow 							[position moveto: position origin x  ((user mp y max: rect origin y + 4) min: rect corner y - 12).							owner scrollTo: (position minY - rect minY - 4) asFloat / (rect height - 12)].						user idle]].				user idle].			nil].		t2]	false]'TextImage understands: 'selecting | t1 t2 t3 t4 t5 t6 t7 t8 	[t1 _ user mp.	t2 _ self charofpoint: t1 andrect [t3].	self complement: off.	self fintype.	[t2 = c1 and c1 = c2 		[while (user redbug and t2 = (self charofpt: user mp)) do			[].		user redbug  false 			[self selectword.			self select.			true]]].	sel _ on.	c2 _ t2.	c1 _ c2.	t4 _ t3 + (1  0).	self complementfrom: t3 to: t4.	t8 _ true.	while [t1 _ user mpnext.	t1] do		[user idle.		t5 _ self charofpoint: t1 andrect [t6].		[c1 = c2  [t7 _ t5  c2]].		[t7 			[[t5 < c1 				[t5 _ c1.				self pointofchar: t5 andrect [t6]]].			self complementfrom: t6 to: t4.			c2 _ t5.			t4 _ t6]		[t5 > c2 			[t5 _ c2.			self pointofchar: t5 andrect [t6]]].		self complementfrom: t3 to: t6.		c1 _ t5.		t3 _ t6].		t3 = t4 			[t4 _ t3 + (1  0).			self complementfrom: t3 to: t4]].	t7  []	self complementfrom: t4 - (1  0) to: t4]'Turtle understands: 'turtleTests"  Evaluate the top and bottom doits separately in order...  | w extent. extent _ 300300.	w _ FormWindow new.	w form: (Form new extent: extent);		title_ ''Turtle''; turtlemode: true;		frame: (200200 rect: extent); show.	user schedule: w.   | pen i tw .  tw _ user''Turtle''.  tw enter.	pen _ Turtle init: tw frame.	pen color: black; width: 2; inking: oring.	for i to: 100 do		[pen go: i * 4; turn: 89].  tw leave."'UserView understands: 'rawkbck | t1 t2 t3 	[NoteTaker and ''NoEventQ'' 		[while [t3 _ user primKbdPeek.		t3] do			[t3  0  [t3]			user primKbdNext].		user idle.		false]	while [t1 _ Events peek.	t1] do		[t1 isKbdDown  [t1 stroke]		Events next].	false]'UserView understands: 'runTicks	["Run through the scheduler sending tick to any window with style: ticking"	"This is experimental and may foul up our nice throttling of CPU cycles"	"I apologize in advance for using a class variable for tickIndex."	"Runs at most one window tick per call on idle"	[tickIndex  nil  [tickIndex _ 1]	 tickIndex _ tickIndex + 1.	 tickIndex  sched length  [tickIndex _ 1]].	while tickIndex  sched length do		[(schedtickIndex) style: ticking  [ (schedtickIndex) tick]		tickIndex _ tickIndex + 1]	]'UserView understands: 'waitbug 	[until self anybug do		[user idle].	self mp]'UserView understands: 'waitnobug 	[while self anybug do		[user idle].	self mp]'Window understands: 'bluebug  | str 	[windowmenu bug		=1[exitflag _ false];		=2[self newframe; enter];		=3[self close. user unschedule: self. self restore. self leave. false];		=4[self style: noTitle _ (self style: noTitle)  false. user restore];		=5[self styleEdit];		=6[self forgetBits; leave; enter];		=7[self hardcopy];		=8[ self duplicate];		=9[str _ user request: ''New Title? ''. titlepara _ str asParagraph allBold];		=10[self style: ticking _ true];		=11[self style: ticking _ false];		=12[self inspect]]'Window understands: 'classInit   "Window classInit. " 	[border _ 2  2.	titleframe _ Textframe new para: ''ignore'' asParagraph frame: (5050 rect: 100100).	titleloc _ 3  (4 - titleframe lineheight).	titlerun _ String new: 2.	titlerun word: 1 _ 255.	(defaultStyle _ Dictionary new: 10)		insert: fill with: white;		insert: borderWidth with: 2;		insert: borderColor with: black.	windowmenu _ Menu new string: ''to bottomframeclosetoggle titleborder & fillrestoreprintduplicatenew titlestart tickingstop tickinginspect'']'Window understands: 'tick  "default is no action"'Window classInit